%%%%%%
% Model of a Logical Hidden Markov Model (LOHMM)
% LM = (SIGMA, MU, DELTA, UPSILON)
% Where
%    SIGMA := logical alphabet
%    MU := selection (grounding) probability over SIGMA
%    DELTA := set of abstract transitions T = (p : H <- B emitting O)
%    UPSILON := set of abstract transitions encoding a prior distribution of states
% ---
% Example taken from "Logical Hidden Markov Models" - Kersting, De Raedt, Raiko; Figure 1.
%
% Each of the LOHMM parameters are encoded via a different set of PRISM switches.
%
% [UPSILON]
%     * The prior distribution simply makes a choice from a set of abstract states. 
%
% [MU]
%     * Logical variables are encoded via uppercase string constants such as 'U' and 'F'.
%     This is due to PRISM needing a ground instance of msw().
%     * Non-ground predicates are represented by abs(Predicate) terms and each non-ground
%     logical variable is ground one by one until the term is fully ground.
%
% [DELTA]
%     * Ground predicates are represented as Predicate and can transition to other ground
%     predicates or back to abstract predicates.
% ---
% USAGE:
%     * ?- sample(lohmm(Observations)).
%     Returns a list of observations emitted from the LOHMM (or 'no' if Observations = ['STOP'])
%
%     * ?- sample(lohmm(Observations, States)).
%     Returns a list of observations emitted and states traversed via the LOHMM (or 'no' if Observations = ['STOP'])
%%%%%%

%%------------------------------------
%% Declarations section
%%------------------------------------

%%
% [UPSILON] Prior distribution on starting states
%%
values(init, [abs(ls('U')), abs(emacs('F', 'U'))]).

%%
% [MU] Grounding rules
% Result of selection probability.
%%

% emacs/2
values(abs(emacs('F', U)), [mu_emacs_0]).
values(abs(emacs(F, 'U')), [mu_emacs_1]).

values(mu_emacs_0, [abs(emacs('f1', arg(2))), abs(emacs('f2', arg(2)))]).
values(mu_emacs_1, [abs(emacs(arg(1), 'tex')), abs(emacs(arg(1), 'other'))]).

% ls/1
values(abs(ls('U')), [mu_ls_0]).

values(mu_ls_0, [abs(ls('tex')), abs(ls('other'))]).

% latex/2
values(abs(latex('F', U)), [mu_latex_0]).
values(abs(latex(F, 'U')), [mu_latex_1]).

values(mu_latex_0, [abs(latex('f1', arg(2))), abs(latex('f2', arg(2)))]).
values(mu_latex_1, [abs(latex(arg(1), 'tex')), abs(latex(arg(1), 'other'))]).

%%
% [DELTA] Abstract transitions
% Result of msw(B, [O, H]) represents T = (p : H <- B emitting O).
% values/2 for more general B should be placed below values/2 for more specific B, implementing the subsumption constraint.
%%

% emacs/2
values(emacs(F, 'tex'), [delta_emacs_0]).
values(emacs(F, U), [delta_emacs_1]).

values(delta_emacs_0, [[emacs(arg(1)), abs(ls('U'))], [emacs(arg(1)), abs(emacs('F', 'U'))], [emacs(arg(1)), abs(latex(arg(1), 'tex'))], ['STOP', abs(stop)]]).

values(delta_emacs_1, [[emacs(arg(1)), abs(ls('U'))], [emacs(arg(1)), abs(emacs('F', arg(2)))], ['STOP', abs(stop)]]).

% ls/1
values(ls(U), [delta_ls_0]).

values(delta_ls_0, [[ls, abs(ls(arg(1)))], [ls, abs(emacs('F', 'U'))], ['STOP', abs(stop)]]).

% latex/2
values(latex(F, 'tex'), [delta_latex_0]).

values(delta_latex_0, [[latex(arg(1)), abs(ls('U'))], [latex(arg(1)), abs(emacs('F', 'U'))], [latex(arg(1)), abs(emacs(arg(1), 'tex'))], ['STOP', abs(stop)]]).

%%------------------------------------
%% Modeling section
%%------------------------------------

l_vars(['F', 'U']).  % List of logical variables used in LOHMM

%%
% [lohmm/1] lohmm(Observations)
% ---
% Observations := a list of observations emitted from the LOHMM
% ---
% Returns the list of observations.
%%
lohmm(Obs) :- lohmm(Obs, _).

%%
% [lohmm/2] lohmm(Observations, States)
% ---
% Observations := a list of observations emitted from the LOHMM
% States := a list recording the state sequence of the LOHMM
% ---
% Returns the list of observations and state sequence.
%%
lohmm(Obs, [Ground | States]) :-
    set_params,
    msw(init, Abs),                  % Pick initial abstract state
    select(Abs, Ground),             % Ground the initial state
    trans(Ground, Obs, States),      % Transition via ground state while recording observation and state sequence
    Obs \= ['STOP'].                 % Disallow sequences to terminate without emiting some output

%%
% [select/2] select(Abs, Next)
% ---
% Abs := partially ground abstract state
% Next := the result of grounding a single variable in Abs
% ---
% Implements the selection function MU.
% Each logical variable is ground one at a time and the recursion terminates
% when none of the arguments to the predicate are in the set l_vars.
%%
select(abs(Ground), Ground) :-
    Ground =.. [_ | Args],           % Split the predicate into [Name | Args] to check arguments
    l_vars(V),                       % V = {logical variables}
    intersection(Args, V, []), !.    % End recursion if all logical variables are ground

select(Abs, Ground) :-
    msw(Abs, X),                     % Partially ground the abstract state
    msw(X, abs(Y)),
    functor(Y, _, N),
    rewrite(Y, Abs, N, Next),
    select(Next, Ground).            % Recurse on the partially ground state

%%
% [trans/3] trans(Ground, Observations, States)
% ---
% Ground := the current ground state
% Observations := a list of observations which has the current state emission as the head
% States := a list of states which has the next state as the head
% ---
% Transitions via the LOHMM rules where 
%     first we select an abstract transition,
%     next we ground the states (if necessary),
%     then we recurse on the next state.
%
% Recursion completes when the LOHMM reaches the 'stop' state.
%%
trans(stop, [], []) :- !.

trans(Ground, [Obs | R1], [Next | R2]) :-
    msw(Ground, X),                  % Select the abstract transition
    msw(X, [Ob, Abs]),
    functor(Ground, _, N),
    rewrite_obs(Ob, Ground, N, Obs),
    print('---THIS IS WHAT WAS PROPOSED: '), print(Abs), print('----'), nl,
    select(Abs, Next),               % Ground the abstract transition
    print('---THIS IS WHAT WAS SELECTED: '), print(Next), print('-----'), nl,
    trans(Next, R1, R2).             % Recurse on the next state while recording sequences

%
%
%
rewrite(S, _, 0, abs(S)) :- print('----DONE ARG REWRITE ----'), print(S), nl, nl, !.

rewrite(String, abs(M), N, Next) :-
    print('STRING = '), print(String), nl, 
    print('ITERATION = '), print(N), nl, 
    print('ORIGINAL BODY = '), print(M), nl,
    (  arg(N, String, arg(X))
    -> arg(X, M, Y), setarg(N, String, Y), A is N - 1
    ;  A is N - 1
    ), print('NEXT-----'), nl, rewrite(String, abs(M), A, Next).

%
%
%
rewrite_obs(S, _, _, S) :- 
    print(S),
    S =.. L,
    length(L, 1), nl, print('----DONE OBS REWRITE----'), nl, nl, !.

rewrite_obs(S, _, 0, S) :- print('----DONE OBS REWRITE----'), print(S), nl, nl, !.

rewrite_obs(String, M, N, Next) :-
    print('STRING = '), print(String), nl, 
    print('ITERATION = '), print(N), nl, 
    print('ORIGINAL BODY = '), print(M), nl,
    (  arg(N, String, arg(X))
    -> arg(X, M, Y), setarg(N, String, Y), A is N - 1
    ;  A is N - 1
    ), print('NEXT-----'), nl, rewrite_obs(String, M, A, Next).

%%------------------------------------
%% Utility section
%%------------------------------------

set_params :-
    set_sw(init, [0.55, 0.45]),
    set_sw(delta_emacs_0, [0.2666, 0.0666, 0.5666, 0.1]),
    set_sw(delta_emacs_1, [0.65, 0.25, 0.1]),
    set_sw(delta_latex_0, [0.1666, 0.5666, 0.1666, 0.1]),
    set_sw(delta_ls_0, [0.35, 0.55, 0.1]).