%%%%%%
% Model of a Logical Hidden Markov Model (LOHMM)
% LM = (SIGMA, MU, DELTA, UPSILON)
% Where
%    SIGMA := logical alphabet
%    MU := selection (grounding) probability over SIGMA
%    DELTA := set of abstract transitions T = (p : H <- B emitting O)
%    UPSILON := set of abstract transitions encoding a prior distribution of states
% ---
% Example taken from "Logical Hidden Markov Models" - Kersting, De Raedt, Raiko; Figure 1.
%
% Each of the LOHMM parameters are encoded via a different set of PRISM switches.
%
% [UPSILON]
%     * The prior distribution simply makes a choice from a set of abstract states. 
%
% [MU]
%     * Logical variables are encoded via uppercase string constants such as 'U' and 'F'.
%     This is due to PRISM needing a ground instance of msw().
%     * Non-ground predicates are represented by abs(Predicate) terms and each non-ground
%     logical variable is ground one by one until the term is fully ground.
%
% [DELTA]
%     * Ground predicates are represented as Predicate and can transition to other ground
%     predicates or back to abstract predicates.
% ---
% USAGE:
%     * ?- sample(lohmm(Observations)).
%     Returns a list of observations emitted from the LOHMM (or 'no' if Observations = ['STOP'])
%
%     * ?- sample(lohmm(Observations, States)).
%     Returns a list of observations emitted and states traversed via the LOHMM (or 'no' if Observations = ['STOP'])
%%%%%%

%%------------------------------------
%% Modeling section
%%------------------------------------

lohmm(Obs) :-
    lohmm(_, Obs).

lohmm(States, Obs) :-
    set_params,                                 
    lohmm(start, [start | States], [_ | Obs]),  
    Obs \= [stop].                              

lohmm(stop, [], []) :- !.

lohmm(State, [State|States], [Obs|Obss]) :- 
    trans(State, Obs, Next),      
    generateID(Obs, ID1),  
    generateID(Next, ID2),  
    bind(Obs, ID1),        
    bind(Next, ID2),        
    lohmm(Next, States, Obss).    

trans(State, Obs, Next) :-
    msw(State, Rule_ID),         
    msw(Rule_ID, Rule),         
    rule(Rule, State, (Obs, Next)).  

bind(State, ID) :- 
    functor(State, F, N),         
    State =.. [F|Args],             
    allbind(F/N, 1, Args, ID). 

allbind(F/N, _, [], ID) :- !. 

allbind(F/N, I, [Arg|Args], ID) :-
    (  var(Arg)            
    -> msw(mu(F/N-I), Arg) 
    ;  true
    ),                         
    I1 is I + 1,
    allbind(F/N, I1, Args, ID).

generateID(Term, 0) :- ground(Term), !.

generateID(Term, ID) :-
    Term =.. [_ | Args],
    length(Args, N),
    foreach((Arg, I) in (Args, 1..N), ac(ID, 0),
        (  var(Arg)
        -> ID^1 is ID^0 + I
        ;  ID^1 is ID^0 
        )
    ).

%%------------------------------------
%% Declarations section
%%------------------------------------

%%
% [UPSILON] Prior distribution on starting states
%%
values(start, [start_r]).
values(start_r, [start_r_1, start_r_2]).

rule(start_r_1, start, (null, ls(U))).
rule(start_r_2, start, (null, emacs(F, U))).

%%
% [MU] Grounding rules
% ---
% Each variable in the term has an associated probability over a typed domain.
% It is assumed that the arguments are distributed independently via naive Bayes assumption (wrt the term name).
% Variables which appear multiple times in a term will be bound once and the value shared via unification.
%%

% emacs/2
values(mu(emacs/2-1), [f1, f2]).
values(mu(emacs/2-2), [tex, other]).

% latex/2
values(mu(latex/2-1), [f1, f2]).
values(mu(latex/2-2), [tex, other]).

% ls/1
values(mu(ls/1-1), [tex, other]).

%%
% [DELTA] Abstract transitions
% ---
% Each ground state is first matched to the most specific abstract state,
%     then the transition is chosen based on transition probability,
%     then the rule/2 which deterministically unifies is selected.
%
% values/2 for more general B should be placed below values/2 for more specific B, implementing the subsumption constraint.
%%

% ls(U)
values(ls(U), [ls_r]).
values(ls_r, [ls_r_1, ls_r_2, stop]). 

rule(ls_r_1, ls(U), (ls, ls(U))).
rule(ls_r_2, ls(U), (ls, emacs(F, U1))).

% emacs(F, tex)
values(emacs(F, tex), [emacs_2_r]).
values(emacs_2_r, [emacs_2_r_1, emacs_2_r_2, emacs_2_r_3, stop]).

rule(emacs_2_r_1, emacs(F, tex), (emacs(F), ls(U1))).
rule(emacs_2_r_2, emacs(F, tex), (emacs(F), emacs(F1, tex))).
rule(emacs_2_r_3, emacs(F, tex), (emacs(F), latex(F, tex))).

% emacs(F, U)
values(emacs(F, U), [emacs_1_r]).
values(emacs_1_r, [emacs_1_r_1, emacs_1_r_2, stop]).

rule(emacs_1_r_1, emacs(F,U), (emacs(F), emacs(F1, U))).
rule(emacs_1_r_2, emacs(F,U), (emacs(F), ls(U1))).

% latex(F, tex)
values(latex(F, tex), [latex_r]).
values(latex_r, [latex_r_1, latex_r_2, latex_r_3, stop]).

rule(latex_r_1, latex(F, tex), (latex(F), ls(U1))).
rule(latex_r_2, latex(F, tex), (latex(F), emacs(F1,U))).
rule(latex_r_3, latex(F, tex), (latex(F), emacs(F,tex))).

% stop state
rule(stop, _, (stop, stop)).

%%------------------------------------
%% Utility section
%%------------------------------------

set_params :-
    set_sw(mu(emacs/2-1), [0.3, 0.7]),
    set_sw(mu(emacs/2-2), [0.55, 0.45]),
    set_sw(start_r, [0.55, 0.45]),
    set_sw(emacs_2_r, [0.2666, 0.0666, 0.5666, 0.1]),
    set_sw(emacs_1_r, [0.25, 0.65, 0.1]),
    set_sw(latex_r, [0.1666, 0.5666, 0.1666, 0.1]),
    set_sw(ls_r, [0.35, 0.55, 0.1]).