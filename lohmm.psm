%%%%%%
% Model of a Logical Hidden Markov Model
% LM = (SIGMA, MU, DELTA, UPSILON)
% Where
%    SIGMA := logical alphabet
%    MU := selection (grounding) probability over SIGMA
%    DELTA := set of abstract transitions T = (p : H <- B emitting O)
%    UPSILON := set of abstract transitions encoding a prior distribution of states
% ---
% Example taken from "Logical Hidden Markov Models" - Kersting, De Raedt, Raiko; Figure 1.
%%%%%%

%%------------------------------------
%% Declarations section
%%------------------------------------

%%
% [UPSILON] Prior distribution on starting states
%%
values(init, [ls('U'), emacs('F', 'U')]).

%%
% [MU] Grounding rules
% Result of selection probability.
% values/2 for more general clauses should be placed below values/2 for more specific clauses, implementing the subsumption constraint.
%%

% emacs/2
values(emacs('F', 'U'), [['NONE', emacs('f1', 'tex')], ['NONE', emacs('f1', 'other')], ['NONE', emacs('f2', 'tex')], ['NONE', emacs('f2', 'other')]]).
values(emacs('F', U), [['NONE', emacs('f1', U)], ['NONE', emacs('f2', U)]]).

% ls/1
values(ls('U'), [['NONE', ls('tex')], ['NONE', ls('other')]]).

%%
% [DELTA] Abstract transitions
% Result of msw(B, [O, H]) represents T = (p : H <- B emitting O).
% values/2 for more general B should be placed below values/2 for more specific B, implementing the subsumption constraint.
%%

% emacs/2
values(emacs(F, 'tex'), [[emacs(F), ls('tex')], [emacs(F), emacs('F', 'tex')], [emacs(F), latex(F, 'tex')], ['NONE', stop]]).
values(emacs(F, U), [[emacs(F), ls('U')], [emacs(F), emacs('F', U)], ['NONE', stop]]).

% ls/1
values(ls(_), [[ls, ls('U')], [ls, emacs('F', 'U')], ['NONE', stop]]).

% latex/2
values(latex(F, U), [[latex(F), ls('U')], [latex(F), emacs('F', U)], [latex(F), emacs(F, U)], ['NONE', stop]]).

%%------------------------------------
%% Modeling section
%%------------------------------------

%%
% [lohmm/2] lohmm(Output, States)
% ---
% Output := a list of observations emitted from the LOHMM
% States := a list recording the state sequence of the LOHMM
%%
lohmm(Obs, [Ground | States]) :-
	set_params,   
    msw(init, Head),                 % Pick initial abstract state
    msw(Head, [_, Ground]),          % Ground the initial state (ignore the output, which is 'NONE')
    trans(Ground, Out, States),      % Transition via ground state while recording observation and state sequence
    subtract(Out, ['NONE'], Obs),    % Beautify output by removing 'NONE' tokens
    Obs \= [].					     % Disallow sequences to terminate without emiting some output

%%
% [trans/3] trans(Ground, Observations, States)
% ---
% Ground := the current ground state
% Observations := a list of observations which has the current state emission as the head
% States := a list of states which has the next state as the head
%%
trans(stop, [], []) :- !.

trans(Ground, [Obs | R1], [Next | R2]) :- 
    msw(Ground, [Obs, Next]),        % Select the abstract transition
    trans(Next, R1, R2).             % Recurse on the next state while recording sequences

%%------------------------------------
%% Utility section
%%------------------------------------

set_params :-
	set_sw(init, [0.55, 0.45]),
	set_sw(emacs('f1', 'tex'), [0.2666, 0.0666, 0.5666, 0.1]),
	set_sw(emacs('f2', 'tex'), [0.2666, 0.0666, 0.5666, 0.1]),
	set_sw(emacs('f1', 'other'), [0.65, 0.25, 0.1]),
	set_sw(emacs('f2', 'other'), [0.65, 0.25, 0.1]),
	set_sw(latex('f1', 'tex'), [0.1666, 0.5666, 0.1666, 0.1]),
	set_sw(latex('f2', 'tex'), [0.1666, 0.5666, 0.1666, 0.1]),
	set_sw(ls('tex'), [0.35, 0.55, 0.1]),
	set_sw(ls('other'), [0.35, 0.55, 0.1]).